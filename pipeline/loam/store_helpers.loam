import java.net.URI

import loamstream.model.Store
import loamstream.loam.LoamStore

def outputStoreName(name: String)(extension: String): String = s"${name}.${extension}"
def outputStore(name: String): String => LoamStore[TXT] = extension => store[TXT].at(outputStoreName(name)(extension))

def withExtensions(extensions: String*)(makeStore: String => LoamStore[TXT]): Seq[LoamStore[TXT]] = {
  extensions.map(ex => makeStore(ex))
}

val (bed, bim, fam) = ("bed", "bim", "fam")
def bedBimFam(makeStore: String => LoamStore[TXT]): Seq[LoamStore[TXT]] = withExtensions(bed, bim, fam)(makeStore)
def bedBimFam(prefix: String): Seq[LoamStore[TXT]] = bedBimFam(extension => store[TXT].at(s"${prefix}.${extension}"))
def bedBimFam(prefix: Path): Seq[LoamStore[TXT]] = bedBimFam(prefix.toString)

case class KlustakwikStores(base: String, fet: LoamStore[TXT], tempClu: LoamStore[TXT], clu: LoamStore[TXT],
                            klg: LoamStore[TXT], metricIds: LoamStore[TXT], klustakwikLog: LoamStore[TXT]) {
  val inputs: Set[LoamStore[TXT]] = Set(fet)
  val outputs: Set[LoamStore[TXT]] = Set(clu, klg, klustakwikLog)
}

object KlustakwikStores {
  def apply(base: String): KlustakwikStores = {
    val makeStore: String => LoamStore[TXT] = extension => store[TXT].at(s"${base}.${extension}")
    val Seq(fet, tempClu, clu, klg, metricIds, klustakwikLog) =
      withExtensions("fet.1", "temp.clu.1", "clu.1", "klg.1", "metric.ids",".klustakwik.log")(makeStore)
    KlustakwikStores(base, fet, tempClu, clu, klg, metricIds, klustakwikLog)
  }

  def apply(base: Path): KlustakwikStores = apply(base.toString)
}
