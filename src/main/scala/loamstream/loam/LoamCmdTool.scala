package loamstream.loam

import loamstream.loam.LoamToken.{StoreRefToken, StoreToken, StringToken, MultiStoreToken, MultiToken}
import loamstream.model.Tool.{AllStores, DefaultStores}
import loamstream.model.{LId, Store, Tool}
import loamstream.util.StringUtils
import loamstream.loam.files.LoamFileManager
import loamstream.conf.DynamicConfig
import loamstream.util.Sequence

/** 
 * @author oliverr
 * @author clint
 * @author kaan
 * 
 * @date 5/25/2016
 *  
 * A command line tool specified in a Loam script
 */
final case class LoamCmdTool private (
    id: LId, 
    name: String, 
    val tokens: Seq[LoamToken])(implicit val scriptContext: LoamScriptContext) extends Tool {

  /** Input and output stores before any are specified using in or out */
  override lazy val defaultStores: DefaultStores = AllStores(LoamToken.storesFromTokens(tokens))

  /** Constructs the command line string */
  lazy val commandLine: String = LoamCmdTool.toString(scriptContext.projectContext.fileManager, tokens)
  
  private[loam] def withName(newName: String): LoamCmdTool = copy(name = newName)
}

object LoamCmdTool {

  implicit final class StringContextWithCmd(val stringContext: StringContext) extends AnyVal {
    /** 
     *  String interpolator for making LoamCmdTools.
     *  
     *  BEWARE: This method has the implicit side-effect of modifying the graph
     *          within scriptContext via the call to addToGraph()
     */
    def cmd(args: Any*)(
        name: String = autoGeneratedName(),
        in: Iterable[Store] = Iterable.empty,
        out: Iterable[Store] = Iterable.empty,
        using: Iterable[String] = Nil)(implicit scriptContext: LoamScriptContext): LoamCmdTool = {
      
      val tool = create(args : _*)(name, StringUtils.unwrapLines)(scriptContext, stringContext)

      val toAdd = addUsing(tool, using)
      
      //NB: Tool must be added to the graph *before* addIns() and addOuts() are called.
      //These methods 'mutate' the graph, and behave incorrectly if the Tool they reference isn't (yet)
      //part of the graph.
      addToGraph(toAdd)
      
      addIns(toAdd, in)
      addOuts(toAdd, out)

      toAdd
    }
  }
  
  /** Adds input stores to this tool */
  private[loam] def addIns(tool: LoamCmdTool, inStores: Iterable[Store]): Unit = {
    if(inStores.nonEmpty) {
      tool.projectContext.updateGraph(_.withInputStores(tool, inStores.toSet))
    }
  }

  /** Adds output stores to this tool */
  private[loam] def addOuts(tool: LoamCmdTool, outStores: Iterable[Store]): Unit = {
    if(outStores.nonEmpty) {
      tool.projectContext.updateGraph(_.withOutputStores(tool, outStores.toSet))
    }
  }
  
  private def addUsing(
      tool: LoamCmdTool,
      dotkits: Iterable[String])(implicit scriptContext: LoamScriptContext): LoamCmdTool = {
    
    if(dotkits.isEmpty) { tool }
    else {
      val prefix = {
        val useuse = "source /broad/software/scripts/useuse"
        val and = "&&"
        val reuse = "reuse -q"
        val reuses = dotkits.mkString(s"$reuse ", s" $and $reuse ", s" $and")
        val openParen = "("
        s"$useuse $and $reuses $openParen"
      }
  
      val useToken = StringToken(prefix)
      val closeParenToken = StringToken(")")
  
      tool.copy(tokens = useToken +: tool.tokens :+ closeParenToken)
    } 
  }
  
  private[this] val nameSequence: Sequence[Int] = Sequence()
  
  def autoGeneratedName(): String = s"cmd-${nameSequence.next()}"
  
  /**
   * @param transform allows for manipulating white space,
   *                  system-dependent markers (e.g. line breaks), etc.
   *                  within a commandline or a block of embedded code
   */
  def create(args: Any*)(name: String, transform: String => String)
            (implicit scriptContext: LoamScriptContext, stringContext: StringContext): LoamCmdTool = {

    def makeStringToken(string: String): StringToken = StringToken(transform(string))
    
    //TODO: handle case where there are no parts (can that happen? cmd"" ?)
    val firstPart +: stringParts = stringContext.parts

    val firstToken: LoamToken = makeStringToken(firstPart)

    val tokens: Seq[LoamToken] = firstToken +: {
      stringParts.zip(args).flatMap { case (stringPart, arg) =>
        Seq(toToken(arg), makeStringToken(stringPart))
      }
    }

    val merged = LoamToken.mergeStringTokens(tokens)

    LoamCmdTool(LId.newAnonId, name, merged)
  }

  /** BEWARE: This method has the side-effect of modifying the graph within scriptContext */
  private def addToGraph(tool: LoamCmdTool)(implicit scriptContext: LoamScriptContext): Unit = {
    scriptContext.projectContext.updateGraph { graph =>
      graph.withTool(tool, scriptContext)
    }
  }
  
  private[loam] def isHasLocationIterable(xs: Iterable[_]): Boolean = {
    xs.nonEmpty && xs.forall(_.isInstanceOf[HasLocation])
  }
  
  def toToken(arg: Any): LoamToken = arg match {
    case store: Store => StoreToken(store)
    case storeRef: LoamStoreRef => StoreRefToken(storeRef)
    //NB: @unchecked is ok here because the check that can't be performed due to erasure is worked around by 
    //the isHasLocationIterable() guard
    case stores: Iterable[HasLocation] @unchecked if isHasLocationIterable(stores) => MultiStoreToken(stores)
    case args: Iterable[_] => MultiToken(args)
    //NB: Will throw if the DynamicConf represents a config key that's not present,
    //or a key that points to a sub-config (ie NOT a string or number)
    case conf: DynamicConfig => StringToken(conf.unpack.toString)
    case arg => StringToken(arg.toString)
  }
  
  def toString(fileManager: LoamFileManager, tokens: Seq[LoamToken]): String = {
    tokens.map(_.toString(fileManager)).mkString
  }
}
